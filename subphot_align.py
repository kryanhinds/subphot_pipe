

from astropy import units as u,wcs,visualization
import argparse
import numpy as np
from astropy.io import fits
import os, sys
import glob, math
from math import sin, cos, tan, asin, sqrt, pi
import time, datetime
import string
import urllib
from subphot_functions import *
from subphot_credentials import *
from plot_formating import *
import random 
from astropy.io import ascii
from photutils.detection import IRAFStarFinder
from astropy.stats import sigma_clipped_stats,sigma_clip,SigmaClip
from astropy.wcs import WCS
from astropy.coordinates import SkyCoord

#ignore warnings
import warnings
warnings.filterwarnings('ignore')

rand_nums_string = ''.join(random.choice(string.digits) for i in range(5))
files_to_remove = []

parser = argparse.ArgumentParser(description='Align images')
# wcs_command='python3 '+self.path+'LT_align.py'+" "+self.path+'bkg_subtracted_science/'+self.sci_img_name+" "+self.ref_img_name+"  -m relative -r 100"

parser.add_argument('-sci', '--science', help='Science image', required=True)
parser.add_argument('-ref', '--reference', help='Reference image', required=True)
parser.add_argument('-fwhm', '--fwhm', default = 3.0,help='FWHM for star finding', required=False)
parser.add_argument('-roundhi', '--roundhi', default = 0.3,help='roundhi for star finding', required=False)
parser.add_argument('-r','--searchrad', default = 100.0, help='Search radius for star finding', required=True)
parser.add_argument('-x', '--maxdist', default = 100.0, help='Maximum distance for star finding', required=False)
parser.add_argument('-a', '--aligncenter', default = [-1., -1.], help='Align center for star finding', required=False)  
parser.add_argument('-m', '--method', default = 'relative', help='Method for star finding', required=True)
parser.add_argument('-n', '--nosave', default = 0, help='No save for star finding', required=False)
parser.add_argument('-q', '--quiet', default = 0, help='Quiet for star finding', required=False)
parser.add_argument('-c', '--catalog', default = '', help='Catalog for star finding', required=False)
parser.add_argument('-l', '--logfile', default = '', help='Logfile for star finding', required=False)
parser.add_argument('-p', '--prefix', default = '', help='Prefix for star finding', required=False)
parser.add_argument('-e', '--reqmatch', default = 2, help='Reqmatch for star finding', required=False)
parser.add_argument('-sat', '--saturation', default = 40000., help='Saturation for star finding', required=False)
parser.add_argument('-v', '--verbose', default ='quiet' , help='Verbose for star finding', required=False)

args = parser.parse_args()

termoutp = args.verbose





class Obj:
    ra = 0.0
    dec = 0.0
    mag = 0.0
    
    ra_rad = 0.0
    dec_rad = 0.0
    
    def __init__(self, inra, indec, inmag):
        self.ra = inra
        self.dec = indec
        self.ra_rad = inra * math.pi/180
        self.dec_rad = indec * math.pi/180
        self.mag = inmag
    
    def rotate(self, dpa_deg, ra0, dec0):
        dpa_rad = dpa_deg * math.pi/180
        sindpa = sin(dpa_rad)
        cosdpa = cos(dpa_rad)
        rascale = cos(dec0*math.pi/180)
        
        #this is only valid for small fields away from the pole.
        x = (self.ra  - ra0 ) * rascale
        y = (self.dec - dec0)
        
        xrot = cosdpa * x - sindpa * y
        yrot = sindpa * x + cosdpa * y
        
        self.ra   = (xrot / rascale) + ra0
        self.dec  =  yrot + dec0 
        self.ra_rad  = self.ra  * math.pi/180
        self.dec_rad =  self.dec * math.pi/180


class ds_obj(Obj):
    x = 0.
    y = 0.
    mag = 0.0
    magerr = 0.0
    ellip = 0.0
    fwhm = 0.0
    flag = 0

    def __init__(self, row): #row is a row of an astropy table generated by photutils IRAFStarFinder
        self.x = float(row['xcentroid'])
        self.y = float(row['ycentroid'])
        self.ra = float(row['ra'])
        self.dec = float(row['dec'])
        self.mag = float(row['mag'])
        self.ellip = float(row['roundness'])
        self.fwhm = float(row['fwhm'])

        self.ra_rad = self.ra * math.pi/180
        self.dec_rad = self.dec * math.pi/180
        self.flag = 0
        # if row['flux'] > saturation:
        #     self.flag = 1
        # else:
        #     self.flag = 0


#Pixel distance
def imdistance(obj1, obj2):
    return ((obj1.x - obj2.x)**2 + (obj1.y - obj2.y)**2)**0.5

#Great circle distance between two points.
def distance(obj1, obj2):
    # both must be Obj's.
    
    ddec = obj2.dec_rad - obj1.dec_rad
    dra  = obj2.ra_rad - obj1.ra_rad
    dist_rad = 2 * asin(sqrt( (sin(ddec/2.))**2 + cos(obj1.dec_rad) * cos(obj2.dec_rad) * (sin(dra/2.))**2))

    dist_deg = dist_rad * 180. / math.pi
    dist_sec = dist_deg * 3600.
    return dist_sec

#Non-great-circle distance is much faster
def quickdistance(obj1, obj2, cosdec):
    ddec = obj2.dec - obj1.dec
    dra  = obj2.ra  - obj1.ra
    if dra > 180: dra = 360 - dra
    return 3600 * sqrt(ddec**2 + (cosdec*dra)**2)


#Compare objects using magnitude.
def magcomp(obj1, obj2): #useful for sorting
    return (obj1.mag > obj2.mag) - (obj1.mag < obj2.mag)

#Check if two values are the same to within a fraction specified.
def fuzzyequal(v1, v2, tolerance):
    return abs(v1/v2 - 1) < tolerance
        
def median(l):
    a = np.array(l)
    return np.median(a)

def stdev(l):
    a = np.array(l)
    return np.std(a)

def mode(l):
    if len(l) == 0: return
    s = np.array(sorted(l))
    d = s[1:] - s[:-1]
    nd = len(d)
    if   nd >= 32: g = nd/16
    elif nd >= 6: g = 2
    else:         g = 1
    #g = max(nd / 16,1)  #sensitive to clusters up to a little less than 1/16 of the data set
    minmean = d.sum()
    imean = nd / 2
    for i in range(nd):
        r = [max(i-g,0),min(i+g,nd)]
        m = d[int(r[0]):int(r[1])].mean()
        if m < minmean: 
            minmean = m
            imean = i
    mode = s[imean] #+ s[imean+1])/2
    return mode

def rasex2deg(rastr):
    rastr = str(rastr).strip()
    ra=rastr.split(':')
    if len(ra) == 1: return float(rastr)
    return 15*(float(ra[0])+float(ra[1])/60.0+float(ra[2])/3600.0)
    
def decsex2deg(decstr):
    decstr = str(decstr).strip()
    dec=decstr.split(':')
    if len(dec) == 1: return float(decstr)
    sign=1
    if (decstr[0] == '-'): sign=-1
    return sign*(abs(float(dec[0]))+float(dec[1])/60.0+float(dec[2])/3600.0)
    
def ffunc(u, v, h):
  (A20, A02, A11, A21, A12, A30, A03) = (h.get('A_2_0',0),h.get('A_0_2',0),h.get('A_1_1',0),h.get('A_2_1',0),h.get('A_1_2',0),h.get('A_3_0',0),h.get('A_0_3',0))
  return A20*u**2  + A02*v**2  + A11*u*v  + A21*u**2*v  + A12*u*v**2  + A30*u**3  + A03*v**3

def gfunc(u, v, h):
    (B20, B02, B11, B21, B12, B30, B03) = (h.get('B_2_0',0),h.get('B_0_2',0),h.get('B_1_1',0),h.get('B_2_1',0),h.get('B_1_2',0),h.get('B_3_0',0),h.get('B_0_3',0))
    return B20*u**2  + B02*v**2  + B11*u*v  + B21*u**2*v  + B12*u*v**2  + B30*u**3  + B03*v**3

def finvfunc(u, v, h):
    (AP20, AP02, AP11, AP21, AP12, AP30, AP03) = (h.get('AP_2_0',0),h.get('AP_0_2',0),h.get('AP_1_1',0),h.get('AP_2_1',0),h.get('AP_1_2',0),h.get('AP_3_0',0),h.get('AP_0_3',0))
    return AP20*u**2 + AP02*v**2 + AP11*u*v + AP21*u**2*v + AP12*u*v**2 + AP30*u**3 + AP03*v**3

def ginvfunc(u, v, h):
    (BP20, BP02, BP11, BP21, BP12, BP30, BP03) = (h.get('BP_2_0',0),h.get('BP_0_2',0),h.get('BP_1_1',0),h.get('BP_2_1',0),h.get('BP_1_2',0),h.get('BP_3_0',0),h.get('BP_0_3',0))
    return BP20*u**2 + BP02*v**2 + BP11*u*v + BP21*u**2*v + BP12*u*v**2 + BP30*u**3 + BP03*v**3

def pix2wcs_sip2(x, y, h):
    u = x - h['CRPIX1']
    v = y - h['CRPIX2']
  
    up = u + ffunc(u,v,h)
    vp = v + gfunc(u,v,h)
  
    drax = h['CD1_1'] * up + h['CD1_2'] * vp
    ddec = h['CD2_1'] * up + h['CD2_2'] * vp

    cosdec = math.cos(math.pi * h['CRVAL2'] / 180.)
    ra  = h['CRVAL1'] + drax/cosdec
    dec = h['CRVAL2'] + ddec

    return (ra, dec)

def ds_extract(sr_filename, nxpix, nypix, border=3, corner=12, minfwhm=1.5, maxfwhm=25, maxellip=0.5, saturation=-1):
    #detect sources in the image and returns a catalog of the detected sources 
    #catalog is an astropy table with the following columns:
    #xcentroid, ycentroid, sharpness, roundness1, roundness2, npix, sky, peak, flux, mag
    #xcentroid, ycentroid are the coordinates of the centroid of the source
    #sharpness is the sharpness of the source
    #roundness1, roundness2 are the roundness or ellipticity of the source
    #npix is the number of pixels in the source
    #sky is the sky background level
    #peak is the peak pixel value
    #flux is the flux of the source
    #mag is the magnitude of the source


    if maxellip == -1: 
        maxellip = 0.5
    if saturation > 0: 
        ds_saturation = saturation
    else:
       ds_saturation = 50000

    if nxpix <= 0: nxpix = 10000
    if nypix <= 0: nypix = 10000

    if os.path.isfile(path+'config_files/temp.cat'):
       os.system('rm -f '+path+'config_files/temp.cat')

    im = fits.open(sr_filename) # get the header to check for SIP distortions
    h = im[0].header # could be in the extension, of course
    siporder = max(h.get('A_ORDER',0), h.get('B_ORDER',0))
    bkg=np.nanpercentile(im[0].data,50)
    im.close()
    
    
    try:
    # Detect Sources
        if 'ref_imgs' not in sr_filename:
            filetype = 'science'
        else:
            filetype = 'reference'
        print(info_g+' Starting source detection in',filetype,'image ')
        detect_data = fits.open(sr_filename)[0].data

        _,__, std = sigma_clipped_stats(detect_data, sigma=3.0)

        #threshold: The absolute image value above which to select sources.
        #fwhm: The full-width half-maximum (FWHM) of the 2D circular Gaussian kernel in units of pixels.
        #sigma_radius=1.5,minsep_fwhm=2.5,sharplo=0.5,sharphi=2.0,roundlo=0.0,roundhi=0.2, how round to find sources, default is 0.2 ... roundhi=1-(b/a)
        # iraffind= IRAFStarFinder(threshold=starscale*self.std,fwhm=3.0,roundhi=0.3)

        
        detected_sources = IRAFStarFinder(threshold=starscale*std*2, fwhm=3.0, roundhi=args.roundhi).find_stars(detect_data) #columns_to_use=['xcentroid', 'ycentroid', 'sharpness', 'roundness1', 'roundness2', 'npix', 'sky', 'peak', 'flux', 'mag'])
        source_coords_pix=np.column_stack((detected_sources['xcentroid'],detected_sources['ycentroid']))
        source_coords_wcs=load_wcs_from_file(filename=sr_filename,coord=source_coords_pix)
        source_coords_wcs_sky = SkyCoord(ra=source_coords_wcs[:,0]*u.deg, dec=source_coords_wcs[:,1]*u.deg,frame='fk5')
        source_ra_deg,source_dec_deg=source_coords_wcs_sky.ra.deg,source_coords_wcs_sky.dec.deg

        detected_sources['ra'] = source_ra_deg
        detected_sources['dec'] = source_dec_deg

        if termoutp!='quiet':
            print(info_g+' Number of detected sources in',filetype,': ',len(detected_sources))

    except Exception as e:
        # print(e)
        print(warn_r+' Error during star detection in ',filetype,'; try adjusting  input values')
        sys.exit(1)

    #Filtering
    minx = border
    miny = border
    maxx = nxpix - border    # This should be generalized
    maxy = nypix - border
    
    
    l = -1
    nds_init = 0
    nds_pass = 0
    xlist = []
    ylist = []
    ds_list = []
    fwhmlist = []
    elliplist = []
    flaglist = []

    while l< len(detected_sources)-1:
        l+=1
        nds_init+=1

        ds_x = detected_sources['xcentroid'][l]
        ds_y = detected_sources['ycentroid'][l]
        ds_fwhm = detected_sources['fwhm'][l]
        ds_ellip = detected_sources['roundness'][l]
        ds_flux = detected_sources['flux'][l]
        ds_pa = detected_sources['pa'][l]

        #Initial filtering
        if ds_ellip > maxellip: continue
        if ds_fwhm < minfwhm: continue
        if ds_fwhm > maxfwhm: continue
        if ds_x < minx: continue
        if ds_y < miny: continue
        if ds_x > maxx: continue
        if ds_y > maxy: continue
        if ds_x + ds_y < corner: continue
        if ds_x + (nypix-ds_y) < corner: continue
        if (nxpix-ds_x) < corner: continue
        if (nxpix-ds_x) + (nypix-ds_y) < corner: continue
        if ds_saturation > 0:
            if ds_flux > ds_saturation:
                ds_flag = 1
                continue  # this will likely overdo it for very deep fields.
            else:
                ds_flag = 0


    
        iobj = ds_obj(detected_sources[l])
        
        ds_list.append(iobj)
        xlist.append(iobj.x)
        ylist.append(iobj.y)
        fwhmlist.append(iobj.fwhm)
        elliplist.append(iobj.ellip)
        flaglist.append(iobj.flag)
        nds_pass += 1

    if termoutp!='quiet':
        print(info_g+' Number of sources passing initial filtering: ',nds_pass)

    #print nsexinit, 'raw sextractor detections'
    #print nsexpass, 'pass initial critiera'

    #  Remove detections along bad columns

    threshprob = 0.0001
    ctbadcol = 0
    for i in range(5):
        txp = 1.0
        xthresh = 1
        while txp > threshprob: 
            txp *= min((len(ds_list)*1.0/nxpix),0.8) # some strange way of estimating the threshold.
            xthresh += 1                          #what I really want is a general analytic expression for
        removelist = []                         #the 99.99% prob. threshold for value of n for >=n out 
        modex = mode(xlist)                     #of N total sources to land in the same bin (of NX total bins)
        for j in range(len(ds_list)):
            if (ds_list[j].x > modex-1) and (ds_list[j].x < modex+1):
                removelist.append(j)
        removelist.reverse()
        if len(removelist) > xthresh:
            # print('removing ',len(removelist),' sources along bad column(s) ')
            # print(xthresh, ' is the x threshold')
            removelist = np.sort(removelist)[::-1]
            for k in removelist:
                del xlist[k]
                del ylist[k]
                del ds_list[k]
                del fwhmlist[k]
                del elliplist[k]
                del flaglist[k]
                ctbadcol += 1

        typ = 1.0
        ythresh = 1
        while typ > threshprob: 
            typ *= min((len(ds_list)*1.0/nypix),0.8)
            ythresh += 1
            removelist = []
            modey = mode(ylist)
        for j in range(len(ds_list)):
            if (ds_list[j].y > modey-1) and (ds_list[j].y < modey+1):
                removelist.append(j)
            removelist.reverse()
        if len(removelist) > ythresh:
            # print('removing ',len(removelist),' sources along bad row(s) ')
            # print(ythresh, ' is the y threshold')
            removelist = np.sort(removelist)[::-1]
            for k in removelist:
                del xlist[k]
                del ylist[k]
                del ds_list[k]
                del fwhmlist[k]
                del elliplist[k]
                del flaglist[k]
                ctbadcol += 1
    if ctbadcol > 0: 
        if termoutp!='quiet':
            print(info_g+' Removed ', ctbadcol, ' detections along bad columns.')

    
    # Remove galaxies and cosmic rays

    if len(fwhmlist) > 5:
        fwhmlist.sort()
        fwhm20 = np.percentile(fwhmlist,20)
        fwhm25 = np.percentile(fwhmlist,25)
        fwhm50 = np.percentile(fwhmlist,50)     #percentile values
        fwhm75 = np.percentile(fwhmlist,75)
        fwhmmode = mode(fwhmlist)
    else:
        fwhmmode = minfwhm
        fwhm20 = minfwhm

    refinedminfwhm = median([0.75*fwhmmode,0.9*fwhm20,minfwhm]) # if CR's are bigger and more common than stars, this is dangerous...

    ngood = 0
    goodds_list = []
    for ds in ds_list:
        #print(sex.x, sex.y, sex.ra, sex.dec, sex.mag, sex.ellip, sex.fwhm, sex.flag)
        if ds.fwhm > refinedminfwhm: # and sex.ellip < ellipmode +elliptol:
            goodds_list.append(ds)
            ngood += 1
    
    #Sort by magnitude
    goodds_list.sort(key=lambda x: x.mag)
    if termoutp!='quiet':
        print(info_g+' Number of sources passing final filtering: ',ngood)
        print(info_g+' Number of sources discarded: ',len(ds_list)-ngood)


    return goodds_list

def getcatalog(catalog, ra, dec, boxsize, minmag=8.0, maxmag=-1, maxpm=60., tryc=False):
    # Get catalog from USNO

    if maxmag == -1:
        maxmag = 999 #default (custom catalog)
        if catalog == 'ub2': maxmag = 21.0#19.5
        if catalog == 'sdss': maxmag = 22.0
        if catalog == 'tmc': maxmag = 20.0

    sepchar = ''    
    if (catalog =='ub2' or catalog=='sdss' or catalog=='tmc'):
        usercat = 0
        racolumn = 1
        deccolumn = 2
        magcolumn = 6
        if catalog=='tmc': magcolumn=3
        if catalog=='sdss': 
            racolumn=7
            deccolumn=8
            magcolumn=11
            sepchar=','
        pmracolumn = 10
        pmdeccolumn = 11    
        if catalog!='sdss':
            queryurl = "http://tdc-www.harvard.edu/cgi-bin/scat?catalog=" + catalog +  "&ra=" + str(ra) + "&dec=" + str(dec) + "&system=J2000&rad=" + str(-boxsize) + "&sort=mag&epoch=2000.00000&nstar=6400"
        else:
            # The WCSTOOLS SDSS lookup doesn't function reliably anymore.
            queryurl = 'http://skyserver.sdss.org/dr12/en/tools/search/x_radial.aspx?whichway=equitorial&ra='+str(ra)+'&dec='+str(dec)+'&radius='+str(boxsize/60.)+'&min_u=0&max_u=30&min_g=0&max_g=30&min_r=0&max_r='+str(maxmag)+'&min_i=0&max_i=30&min_z=0&max_z=30&format=csv&limit=5000' #; DR12
        #print queryurl
        cat = urllib.urlopen(queryurl)
        catlines = cat.readlines()
        cat.close()
        if tryc==True:
            if len(catlines) < 15: 
                return []  # give up right away and try another catalog

        #if len(catlines) > 6400-20:
        #   print 'WARNING: Reached maximum catalog query size.'
        #   print '         Gaps may be present in the catalog, leading to a poor solution or no solution.'
        #   print '         Decrease the search radius.'
    else:
        usercat = 1
        try:
            cat = open(catalog,'r')
            #print('Reading user catalog ', catalog)
        except Exception as e:
            print(warn_r+' Failed to open user catalog ', catalog)
            print(warn_r+' File not found or invalid online catalog.  Specify ub2, sdss, or tmc.')
            print(warn_r+" "+ e)
            return []
        racolumn = 0
        deccolumn = 1   # defaults
        magcolumn = -1    #  (to override, specify in first line using format #:0,1,2)  
        catlines = cat.readlines()
        cat.close()
    #print '                ', maxmag, maxpm
    l = -1
    catlist = []
    fwhmlist = []

    while l < len(catlines)-1:
        l += 1
        inline = catlines[l].strip()
        if len(inline) <= 2: continue
        if inline[0:2] == '#:':
            inlinearg = inline[2:].split(',')
            racolumn = int(inlinearg[0])-1
            deccolumn = int(inlinearg[1])-1
            if len(inlinearg) > 2: magcolumn = int(inlinearg[2])-1
            continue
        if (inline[0] < '0' or inline[0] > '9') and inline[0]!='.': continue #this may be too overzealous about
        if (inline[1] < '0' or inline[1] > '9') and inline[1]!='.': continue # removing comments...

        if sepchar == '': inlinearg = inline.split()
        if sepchar != '': inlinearg = inline.split(sepchar)
        narg = len(inlinearg)
    
        if inlinearg[racolumn].find(':') == -1:
            ra = float(inlinearg[racolumn])
        else:
            ra = rasex2deg(inlinearg[racolumn])
        if inlinearg[deccolumn].find(':') == -1:
            dec = float(inlinearg[deccolumn])
        else:
            dec = decsex2deg(inlinearg[deccolumn])
        if magcolumn >= 0 and narg > magcolumn: 
            try:
               mag = float(inlinearg[magcolumn])
            except:
               mag = float(inlinearg[magcolumn][0:-2])
        else:
            mag = maxmag
        if usercat == 0 and narg > pmracolumn and narg > pmdeccolumn:
            pmra = float(inlinearg[pmracolumn])
            pmdec = float(inlinearg[pmdeccolumn])
        else:
            pmra = pmdec = 0

        if mag > maxmag: continue #don't believe anything this faint
        if mag < minmag: continue #ignore anything this bright
        if abs(pmra) > maxpm or abs(pmdec) > maxpm: continue
        #print ' OK',
        iobj = Obj(ra, dec, mag) #process the line into an object
        catlist.append(iobj)
        

    catlist.sort(key=lambda x: x.mag)
    print(info_g+' Found ', len(catlist), ' objects in catalog ', catalog)

    return catlist




def matchlists(list1, list2, maxdist=1.0, logfile='', quiet=1):
    
    n1 = len(list1)
    n2 = len(list2)

    if logfile != '':  f = open(logfile, 'w')
 
    totmatch = 0
    radiff = []
    decdiff = []

    for i in range(n1):
        jmaxdist = maxdist
        matchj = -1
        nmatch = 0
        cosdec = cos(list1[i].dec_rad)
        for j in range(n2):
            dist = quickdistance(list1[i], list2[j], cosdec)
            if dist > jmaxdist: continue
            jmaxdist = dist
            matchj = j
            nmatch += 1
        if nmatch == 1:
            dra = list1[i].ra - list2[matchj].ra
            ddec = list1[i].dec - list2[matchj].dec
            dra_arcsec = dra * cosdec * 3600.
            ddec_arcsec = ddec * 3600.

            radiff.append(dra)
            decdiff.append(ddec)
            totmatch += 1

    if totmatch==0:
        print(warn_y+' No matches.')
        return (0., 0., totmatch)

    avradiff = median(radiff)
    avdecdiff = median(decdiff)

    stdradiff = stdev(radiff)
    stddecdiff = stdev(decdiff)
    rms = np.std(np.sqrt(np.array(radiff)**2 + np.array(decdiff)**2))


    return (avradiff, avdecdiff, totmatch)

def writeregionfile(filename, objlist, color="green",sys=''):
    if sys == '': sys = 'wcs'
    out = open(filename,'w')
    i = -1
    out.write('# Region file format: DS9 version 4.0\nglobal color='+color+' font="helvetica 10 normal" select=1 highlite=1 edit=1 move=1 delete=1 include=1 fixed=0 source\n')
    if sys == 'wcs': 
        out.write('fk5\n')
        for ob in objlist:
            i += 1
            out.write("point(%.7f,%.7f) # point=boxcircle text={%i}\n" % (ob.ra, ob.dec, i))
    if sys == 'img': 
        out.write('image\n')
        for ob in objlist:
            i += 1
            out.write("point(%.3f,%.3f) # point=boxcircle text={%i}\n" % (ob.x, ob.y, i))
        out.close()


def nudge(image, raoffset, decoffset, rms=-1, acc=-1, n=-1, source='', outfile=''):

    im = fits.open(image, mode='update')
    im.verify('silentfix')
    next = len(im)
    ext = 0
    if next > 1: ext = 1
        #print 'nudging, ', next
    im[ext].header['crval1'] = im[ext].header['crval1'] + raoffset/cos((3.1415926/180.)*decoffset)
    im[ext].header['crval2'] = im[ext].header['crval2'] + decoffset

    im[ext].header.set('RANUDGE', raoffset*3600.,  comment='RA shift in arcsec')
    im[ext].header.set('DECNUDGE', decoffset*3600., comment='Dec shift in arcsec')
    if acc > 0:
          im[ext].header.set('RMSNUDGE', rms, comment='Per-star scatter in shift')
    if rms > 0:
          im[ext].header.set('ACCNUDGE', acc, comment='Uncertainty in shift')
    if n > 0:
          im[ext].header.set('NNUDGE', n, comment='Number of stars used in shift')
    if len(source) > 0:
          im[ext].header.set('NUDGESRC', source, comment='Image or catalog aligned against')
 

    im.writeto(outfile, output_verify='silentfix', overwrite=True)
    im.close()
    if termoutp!='quiet':
        print(info_g+' Wrote nudge-corrected image to '+outfile)


def main():
    filenames = []
    if 'method' in args.__dict__:
        method=args.method
    else:
        method = 'relative' # align first image to catalog, then subsequent images to first image

    if 'aligncenter' in args.__dict__:
        aligncenter = [-1.,-1.]
        incra,incdec = args.aligncenter[0], args.aligncenter[1]
        if ':' in str(incra):
            aligncenter[0] = rasex2deg(incra)
        else:
            aligncenter[0] = float(incra)

        if ':' in str(incdec):
            aligncenter[1] = decsex2deg(incdec)
        else:
            aligncenter[1] = float(incdec)
    else:
        aligncenter = [-1., -1.]

    if 'searchrad' in args.__dict__:
        searchrad = float(args.searchrad)
        relsearchrad = searchrad
        abssearchrad = searchrad
    else:
        searchrad = 100.
        relsearchrad = 30. # for aligning images against each other
        abssearchrad = 60. # for aligning images against the catalog


    nosave = args.nosave
    quiet = args.quiet
    logfile = args.logfile
    prefix = args.prefix
    maxdist = float(args.maxdist)
    saturation = args.saturation



    if 'catalog' in args.__dict__:
        catalog = args.catalog
    else:
        catalog = ''

    if 'prefix' in args.__dict__:
        prefix = args.prefix
    else:
        prefix = ''

    if 'reqmatch' in args.__dict__:
        reqmatch = int(args.reqmatch)
    else:
        reqmatch = 2

    filenames = []
        
    if not os.path.exists(args.science):
        print(warn_r+" Science image can't be found")
        sys.exit()
    else:
        filenames.append(args.science)

    if not os.path.exists(args.reference):
        print(warn_r+" Reference image can't be found")
        sys.exit()
    else:
        filenames.append(args.reference)


    if len(filenames)<2:
        print(warn_y+' Need at least two images to align!')
        return

    # if aligncenter[0] <= -1.:
        # if quiet==0:
        #     print(warn_y+' No alignment center specified defaulting to CRVAL1/2 of science image')


    im = fits.open(filenames[0])
    next = len(im)
    ext = 0
    for ext in range(next):
        try:
            aligncenter[0] = im[ext].header['crval1']
            aligncenter[1] = im[ext].header['crval2']
            break
        except:
            pass
         #if quiet==0: 
            #print('Using '+filenames[0]+' rotation center CRVAL1='+str(aligncenter[0])+', CRVAL2='+str(aligncenter[1]))
    center = Obj(aligncenter[0], aligncenter[1], 0.0)
    cosdec = cos(center.dec_rad)
    nfiles = len(filenames)


    if method == 'hybrid' or method == 'absolute':
      # Download catalog from the web

      # Load in reference star catalog
      if catalog != '':
          catlist = getcatalog(catalog, aligncenter[0], aligncenter[1], abssearchrad, tryc=False)
      # If no catalog specified, try SDSS, and if nothing returns try USNO
      else:
        trycats = ['sdss', 'ub2', 'tmc']  # need to update this.  tdc is really slow.
        for trycat in trycats:
            catlist = getcatalog(trycat, aligncenter[0], aligncenter[1], abssearchrad, tryc=True)
            if len(catlist) >= 3:
                mindist = 999999.
                cosdec = cos(aligncenter[1]*3.14159/180.)
                for c in catlist:
                   dist = abs(c.ra - aligncenter[0])*cosdec/3600. + abs(c.dec - aligncenter[1])/3600.
                   if dist < mindist: mindist = dist
                if mindist > 90.: continue  # sometimes just off an edge of SDSS
                catalog = trycat
                break
        if (catalog == ''):
            print(warn_r+' No catalog found within '+str(abssearchrad)+' arcsec of '+str(aligncenter[0])+','+str(aligncenter[1]))
            
            return -1

      writeregionfile('icat.reg',catlist,sys='wcs')


      # Match image(s) to catalog
      if method == 'hybrid': frange = [0]
      if method == 'absolute': frange = range(nfiles)
      for f in frange:
        inlist = sextract(filenames[f], 0, 0, 3, 12, maxellip=0.7, saturation=-1)
        for i in range(len(inlist)-1,0,-1):
           cdist = quickdistance(center, inlist[i], cosdec)
           if cdist > abssearchrad: inlist.remove(inlist[i])
        writeregionfile('initpos.reg',inlist,sys='img')

        # Match and align image against the catalog
        (raoff, decoff, nmatch) = matchlists(inlist, catlist, logfile=logfile, maxdist=maxdist)
        if nmatch >= reqmatch:
           try:
              if nosave==0: nudge(filenames[f], -raoff, -decoff, source=catalog, outfile=prefix+filenames[f])
           except:
              if quiet==0: 
                print(warn_r+ ' XXX')
                print(warn_r+ ' FAILURE: Could not change image coordinates - probably could not find the offset')
                print(warn_r+ ' XXX')
              else:
               if nmatch > 0: 
                print(warn_r+ ' Not enough matches to nudge ('+str(nmatch)+' found, '+str(reqmatch)+' required)')

    # Match images to reference (first) image
    if method == 'hybrid' or method == 'relative':

      for f in range(nfiles):
        inlist = ds_extract(filenames[f], 0, 0, 3, 12, maxellip=0.7, saturation=-1)  # sextracting again for image 0 slightly inefficient
        for i in range(len(inlist)-1,-1,-1):
            cdist = quickdistance(center, inlist[i], cosdec)
            if cdist > relsearchrad: inlist.remove(inlist[i])

        #writeregionfile('ipos'+str(f)+'.reg',inlist,sys='img')
        #writeregionfile('ipos'+str(f)+'wcs.reg',inlist,sys='wcs')
        if f == 0: 
            reflist = inlist  # don't match image 0, but transfer inlist to reference list
        else:
            # print(filenames[0], 'vs.', filenames[f])
            (raoff, decoff, nmatch) = matchlists(inlist, reflist)
            if nmatch >= reqmatch:
               try:
                  if nosave==0: nudge(filenames[f], -raoff, -decoff, source=filenames[0], outfile=prefix+filenames[f])
               except:
                  if quiet==0: print(warn_r+ ' XXX')
                  print(warn_r+ ' FAILURE: Could not change image coordinates - probably could not find the offset')
                  if quiet==0: print(warn_r+ ' XXX')
            else:
               print(' Not enough matches to nudge ('+str(nmatch)+'found, '+str(reqmatch)+'required)')

    print(info_g+" Pre-alignment xy nudge completed")
    for remove_file in files_to_remove:
        if os.path.exists(remove_file):
            if termoutp!='quiet':
                print(info_g+" Removing temporary file: "+remove_file.join(", "))
            os.remove(remove_file)
    return

######################################################################
# Running as executable
if __name__=='__main__':
    main()

######################################################################


